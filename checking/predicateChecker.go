package checking

import (
	"bytes"
	"fmt"
	"gomc/event"
	"gomc/state"
	"text/tabwriter"
)

// Response generated by the PredicateChecker
type predicateCheckerResponse[S any] struct {
	// True if all tests holds. False otherwise
	Result bool
	// A sequence of states leading to the false test. nil if Result is true
	Sequence []state.GlobalState[S]
	// The index of the failing test. -1 if Result is true
	Test int
}

// Generate a response.
//
// Returns two variables, result, and description.
// Result is true if all predicates hold, false otherwise.
// Description is a formatted string providing a detailed description of the result.
// If result is false the description contain a representation of the sequence of states that lead to the failing state
func (pcr predicateCheckerResponse[S]) Response() (bool, string) {
	if pcr.Result {
		return pcr.Result, "All predicates holds"
	}
	var buffer bytes.Buffer
	wrt := tabwriter.NewWriter(&buffer, 4, 4, 0, ' ', 0)
	out := fmt.Sprintf("Predicate broken. Predicate: %v. Sequence: \n", pcr.Test)
	for _, element := range pcr.Sequence {
		fmt.Fprintf(wrt, "-> %v \n", element)
	}
	wrt.Flush()
	out += buffer.String()
	return pcr.Result, out
}

// Export the failing event sequence to a slice of EventIds
func (pcr predicateCheckerResponse[S]) Export() []event.EventId {
	evtSequence := []event.EventId{}
	if pcr.Sequence == nil {
		return evtSequence
	}
	for _, state := range pcr.Sequence {
		if state.Evt.Id == "" {
			continue
		}
		evtSequence = append(evtSequence, state.Evt.Id)
	}
	return evtSequence
}

// A function defining a property to be verified.
//
// Takes a checking.State as input.
// Returns true if the property holds for the state and false otherwise.
type Predicate[S any] func(s State[S]) bool

// A Checker that defines properties using Predicates
type PredicateChecker[S any] struct {
	// A slice of predicates that define the properties
	predicates []Predicate[S]
}

// Create a PredicateChecker
//
// predicates is a variadic parameter of predicates that define the properties that should be checked
func NewPredicateChecker[S any](predicates ...Predicate[S]) *PredicateChecker[S] {
	return &PredicateChecker[S]{
		predicates: predicates,
	}
}

// Checks that all predicates holds for all states in the state space.
//
// States are searched depth first and the search is interrupted if some state that breaks the predicates are provided
// Returns a CheckerResponse containing the result of the checking
func (pc *PredicateChecker[S]) Check(root state.StateSpace[S]) CheckerResponse {
	if resp := pc.checkNode(root, []state.GlobalState[S]{}); resp != nil {
		return resp
	}
	return &predicateCheckerResponse[S]{
		Result:   true,
		Sequence: nil,
		Test:     -1,
	}
}

// Use a depth first search to search trough all nodes and check with predicates
// 
// Checks the state of the current node.
// Immediately stops when finding a state that violates the predicates.
// If the states does not violate the predicates, the method is recursively called on the children of the node. 
func (pc *PredicateChecker[S]) checkNode(node state.StateSpace[S], sequence []state.GlobalState[S]) *predicateCheckerResponse[S] {
	sequence = append(sequence, node.Payload())
	if ok, index := pc.checkState(node.Payload(), node.IsTerminal(), sequence); !ok {
		return &predicateCheckerResponse[S]{
			Result:   false,
			Sequence: sequence,
			Test:     index,
		}
	}

	for _, child := range node.Children() {
		if resp := pc.checkNode(child, sequence); resp != nil {
			return resp
		}
	}
	return nil
}

// Check the state of a node on all predicates.
// 
// state is the GlobalState that is stored in the node.
// terminalState is true if this is the last state in the run, false otherwise.
// sequence is the previous states in the run. 
// 
// returns true and -1 if all properties hold.
// Otherwise, returns false and the index of the predicate that was violated.
func (pc *PredicateChecker[S]) checkState(state state.GlobalState[S], terminalState bool, sequence []state.GlobalState[S]) (bool, int) {
	for index, pred := range pc.predicates {
		if !pred(State[S]{
			LocalStates: state.LocalStates,
			Correct:     state.Correct,
			IsTerminal:  terminalState,
			Sequence:    sequence,
		}) {
			return false, index
		}
	}
	return true, -1
}
